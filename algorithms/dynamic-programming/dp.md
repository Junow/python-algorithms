# Dynamic Programming

> 그리디알고리즘과 마찬가지로 최적화 문제를 해결하는 알고리즘이다. dp 는 작은 부분문제들의 해들을 구하고 이들을 이용하여 큰 크기의 부분 문제들을 해결하여 최종적으로 원래 주어진 문제를 해결하는 기법이다.

> dp 를 적용하려면 다음 두가지 조건이 필요하다

1. 최적 부분 문제 구조(Optimal Substrueture)
   주어진 문제가 최적화의 원칙을 만족해야만 한다는 것이고 최적화의 원칙이란 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다는 것이다.
2. 중복 부분문제 구조(Overlapping subproblems)
   큰 문제를 이루는 작은 문제들을 하결하고 작은 문제들의 최적해를 이용하여 순환적으로 큰 문제를 해결한다.

### 분할 정복과 dp의 비교

**분할정복**

- 연관없는 부분 문제로 분할 한다.
- 부분문제를 독립, 재귀적으로 해결한다.
- 부분문제의 해를 결합한다.
- 예) 병합정렬, 퀵정렬

**DP**

- 부분문재들이 연관이 없으면 적용할 수 없다. 즉 부분문제들은 더 작은 부분문제들을 공유한다.
- 모든 부분문제를 한번만 계산하고 결과를 저장하고 재사용한다.
- 분할정복은 같은 부분문제가 나타날 경우 다시 계산한다.

### 메모이제이션

> 메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다. 독적 계획법의 핵심이 되는 기술이다. 이를 위해 추가적인 메모리 공간이 필요하고, 재귀함수 호출로 인한 시스템 호출 스택을 사용하게 되므로 실행 속도 저하 또는 오버플로우가 발생할 수 있다.

### 피보나치 수열

    fibo_dp(n)
      f[0] <- 0
      f[1] <- 1
      FOR i in 2 -> n
        f[i] <- f[i-1] + f[i-2]
      RETURN f[n]

재귀함수는 2^(n/2)번의 함수호출, dp 는 n+1 번 함수호출이 일어난다.
